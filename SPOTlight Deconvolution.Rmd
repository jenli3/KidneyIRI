---
title: "SPOTlight deconvolution"
author: "HarryR"
date: "23/02/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(clusterProfiler)
library(enrichplot)
library(DOSE)
library(ggfortify)
library(org.Mm.eg.db)
library(limma)
library(edgeR)
library(Cepo)
library(SPOTlight)
library(ggplot2)
library(SingleCellExperiment)
library(SpatialExperiment)
library(scater)
library(Seurat)
library(SeuratObject)
library(scran)
```

Loading in the SpatialTranscriptomics Dataset

```{r}
ST_sce <- readRDS("/dora/nobackup/harryr/TolDC AKI/STAKI/se.0.3.rds")
rownames(ST_sce)
```

```{r load-sc, message=FALSE}
library(TabulaMurisSenisData)
sce <- TabulaMurisSenisDroplet(tissues = "Kidney")$Kidney
```

Quick data exploration:

```{r explo}
table(sce$free_annotation, sce$age)
```

```{r sub-18m}
# Keep cells from 18m mice
sce <- sce[, sce$age == "3m"]
# Keep cells with clear cell type annotations
sce <- sce[, !sce$free_annotation %in% c("nan", "CD45")]
```

```{r lognorm}
sce <- logNormCounts(sce)
```

### Variance modelling

We aim to identify highly variable genes that drive biological heterogeneity. 
By feeding these genes to the model we improve the resolution of the biological structure and reduce the technical noise.

```{r variance}
dec <- modelGeneVar(sce)
plot(dec$mean, dec$total, xlab = "Mean log-expression", ylab = "Variance")
curve(metadata(dec)$trend(x), col = "blue", add = TRUE)
# Get the top 3000 genes.
hvg <- getTopHVGs(dec, n = 3000)
```

Next we obtain the marker genes for each cell identity. You can use whichever
method you want as long as it returns a weight indicating the importance of that
gene for that cell type. Examples include `avgLogFC`, `AUC`, `pct.expressed`,
`p-value`...

```{r mgs}
colLabels(sce) <- colData(sce)$free_annotation
# Get vector indicating which genes are neither ribosomal or mitochondrial
genes <- !grepl(pattern = "^Rp[l|s]|Mt", x = rownames(sce))
# Compute marker genes
library(scran, lib.loc = "~/localPackages/")
mgs <- scoreMarkers(sce, subset.row = genes)
```

Then we want to keep only those genes that are relevant for each cell identity:

```{r mgs-df}
mgs_fil <- lapply(names(mgs), function(i) {
    x <- mgs[[i]]
    # Filter and keep relevant marker genes, those with AUC > 0.8
    x <- x[x$mean.AUC > 0.8, ]
    # Sort the genes from highest to lowest weight
    x <- x[order(x$mean.AUC, decreasing = TRUE), ]
    # Add gene and cluster id to the dataframe
    x$gene <- rownames(x)
    x$cluster <- i
    data.frame(x)
})
mgs_df <- do.call(rbind, mgs_fil)
```


```{r downsample}
# split cell indices by identity
idx <- split(seq(ncol(sce)), sce$free_annotation)
# downsample to at most 20 per identity & subset
n_cells <- 2
cs_keep <- lapply(idx, function(i) {
    n <- length(i)
    if (n < n_cells)
        n_cells <- n
    sample(i, n_cells)
})
sce <- sce[, unlist(cs_keep)]
```

## Deconvolution

You are now set to run `SPOTlight` to deconvolute the spots!


```{r SPOTlight}
res <- SPOTlight(
    x = sce,
    y = spe,
    groups = sce$free_annotation,
    mgs = mgs_df,
    hvg = hvg,
    weight_id = "mean.AUC",
    group_id = "cluster",
    gene_id = "gene")
```

Extract data from `SPOTlight`:

```{r}
# Extract deconvolution matrix
head(mat <- res$mat)[, seq_len(3)]
# Extract NMF model fit
mod <- res$NMF
```

# Visualization

```{r plotTopicProfiles1, fig.width=6, fig.height=7}
plotTopicProfiles(
    x = mod,
    y = sce$free_annotation,
    facet = FALSE,
    min_prop = 0.01,
    ncol = 1) +
    theme(aspect.ratio = 1)
```

Next we also want to ensure that all the cells from the same cell identity share 
a similar topic profile since this will mean that `SPOTlight` has learned a
consistent signature for all the cells from the same cell identity.

```{r plotTopicProfiles2, fig.width=9, fig.height=6}
plotTopicProfiles(
    x = mod,
    y = sce$free_annotation,
    facet = TRUE,
    min_prop = 0.01,
    ncol = 6)
```

Lastly we can take a look at which genes the model learned for each topic.
Higher values indicate that the gene is more relevant for that topic. 
In the below table we can see how the top genes for `Topic1` are characteristic
for B cells (i.e. *Cd79a*, *Cd79b*, *Ms4a1*...).

```{r basis-dt, message=FALSE, warning=FALSE}
library(NMF)
sign <- basis(mod)
colnames(sign) <- paste0("Topic", seq_len(ncol(sign)))
head(sign)
# This can be dynamically visualized with DT as shown below
# DT::datatable(sign, fillContainer = TRUE, filter = "top")
```

## Spatial Correlation Matrix

```{r plotCorrelationMatrix, fig.width=9, fig.height=9}
plotCorrelationMatrix(mat)
```

## Co-localization

Now that we know which cell types are found within each spot we can make a graph
representing spatial interactions where cell types will have stronger edges
between them the more often we find them within the same spot.


```{r plotInteractions, fig.width=9, fig.height=9}
plotInteractions(mat, "heatmap")
plotInteractions(mat, "network")
```

## Scatterpie

We can also visualize the cell type proportions as sections of a pie chart for 
each spot. You can modify the colors as you would a standard `r CRANpkg("ggplot2")`.

```{r Scatterpie, fig.width=9, fig.height=6}
ct <- colnames(mat)
mat[mat < 0.1] <- 0
# Define color palette
# (here we use 'paletteMartin' from the 'colorBlindness' package)
paletteMartin <- c(
    "#000000", "#004949", "#009292", "#ff6db6", "#ffb6db", 
    "#490092", "#006ddb", "#b66dff", "#6db6ff", "#b6dbff", 
    "#920000", "#924900", "#db6d00", "#24ff24", "#ffff6d")
pal <- colorRampPalette(paletteMartin)(length(ct))
names(pal) <- ct

plotSpatialScatterpie(
    x = spe,
    y = mat,
    cell_types = colnames(y),
    img = FALSE,
    scatterpie_alpha = 1,
    pie_scale = 0.11) +
    scale_fill_manual(
        values = pal,
        breaks = names(pal))
?plotSpatialScatterpie
```

## Residuals

Lastly we can also take a look at how well the model predicted the proportions
for each spot. We do this by looking at the residuals of the sum of squares for
each spot which indicates the amount of biological signal not explained by the model.

```{r message=FALSE}
spe$res_ss <- res[[2]][colnames(spe)]
xy <- spatialCoords(spe)
spe$x <- xy[, 1]
spe$y <- xy[, 2]
ggcells(spe, aes(x, y, color = res_ss)) +
    geom_point() +
    scale_color_viridis_c() +
    coord_fixed() +
    theme_bw()
```

# Session information

```{r session-info}
sessionInfo()
```



